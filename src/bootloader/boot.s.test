#define ASM_FILE    1
#include <multiboot.h>

/* C symbol format. HAVE_ASM_USCORE is defined by configure. */
#ifdef HAVE_ASM_USCORE
# define EXT_C(sym)   _ ## sym
#else
# define EXT_C(sym)   sym
#endif // HAVE_ASM_USCORE

#define STACK_SIZE      0x4000

#ifdef __ELF__
# define AOUT_KLUDGE 0
#else
# define AOUT_KLUDGE MULTIBOOT_AOUT_KLUDGE
#endif // __ELF__

.text
.globl start, _start
start:
_start:
    jmp     multiboot_entry

    .align 8
    
multiboot_header:
    .long MULTIBOOT_MAGIC
    .long GRUB_MULTIBOOT_ARCHITECTURE_I386
    .long multiboot_header_end - multiboot_header
    .long -(MULTIBOOT2_HEADER_MAGIC + GRUB_MULTIBOOT_ARCHITECTURE_I386 + (multiboot_header_end - multiboot_header))

#ifndef __ELF__
address_tag_start:
    .short MULTIBOOT_HEADER_TAG_ADDRESS
    .short MULTIBOOT_HEADER_TAG_OPTIONAL
    .long address_tag_end - address_tag_start

    .long multiboot_header
    .long _start
    .long _edata
    .long _end
address_tag_end:
entry_address_tag_start:
    .short MULTIBOOT_HEADER_TAG_ENTRY_ADDRESS
    .short MULTIBOOT_HEADER_TAG_OPTIONAL
    .long entry_address_tag_end - entry_address_tag_start
    .long multiboot_entry
entry_address_tag_end:
#endif // __ELF__

framebuffer_tag_start:
    .short MULTIBOOT_HEADER_TAG_FRAMEBUFFER
    .short MULTIBOOT_HEADER_TAG_OPTIONAL
    .long framebuffer_tag_end - framebuffer_tag_start
    .long 1024
    .long 768
    .long 32
framebuffer_tag_end:
multiboot_header_end:

multiboot_entry:
    // Initialize the stack pointer.
    movl    $(stack + STACK_SIZE), %esp

    // Reset EFLAGS.
    pushl   $0
    popf

    // Push the pointer to the multiboot information structure
    pushl   %ebx

    // Push the magic value
    pushl   %eax

    // Now call kernel_entry (which is a C function).
    call    kernel_entry

    // Halt
    pushl   $halt_message
    call    kprintf

loop:   hlt
    jmp loop

halt_message:
    .asciz  "Halted"
